use std::fs;
use std::path::Path;

fn main() {
    // Detect root repository context
    // Check if we're in the root repo by looking for:
    // 1. ../.git exists (root repo has .git)
    // 2. ../gsnake-core/Cargo.toml exists (sibling gsnake-core directory exists)
    // Note: gsnake-core is NOT a git submodule, it's a regular directory

    let parent_git = Path::new("../.git");
    let gsnake_core_toml = Path::new("../gsnake-core/Cargo.toml");

    let is_root_repo = parent_git.exists() && gsnake_core_toml.exists();

    if is_root_repo {
        println!("cargo:warning=Root repository detected - using local gsnake-core");

        // Create or update .cargo/config.toml to patch the git dependency
        // We'll append a [patch] section to override the git dependency with local path
        let cargo_dir = Path::new(".cargo");
        let config_path = cargo_dir.join("config.toml");

        // Read existing config if it exists
        let existing_config = if config_path.exists() {
            fs::read_to_string(&config_path).unwrap_or_default()
        } else {
            String::new()
        };

        // Check if patch section already exists
        if !existing_config.contains("[patch.\"https://github.com/nntin/gsnake\"]") {
            // Append patch section
            let patch_section = r#"
# Auto-generated by build.rs - Local override for root repository development
# This patches the git dependency to use the local sibling gsnake-core package
# Note: gsnake-core is a workspace, so we point to the actual package at engine/core
[patch."https://github.com/nntin/gsnake"]
gsnake-core = { path = "../gsnake-core/engine/core" }
"#;

            let new_config = if existing_config.is_empty() {
                patch_section.to_string()
            } else {
                format!("{}\n{}", existing_config, patch_section)
            };

            fs::write(&config_path, new_config)
                .expect("Failed to write .cargo/config.toml");

            println!("cargo:warning=Created local path override in .cargo/config.toml");
        } else {
            println!("cargo:warning=Local path override already configured");
        }

        // Tell cargo to re-run this script if parent .git or sibling Cargo.toml changes
        println!("cargo:rerun-if-changed=../.git");
        println!("cargo:rerun-if-changed=../gsnake-core/Cargo.toml");
    } else {
        println!("cargo:warning=Standalone mode - using git dependency for gsnake-core");

        // In standalone mode, ensure we don't have a patch section
        // (This is important if switching between modes)
        let cargo_dir = Path::new(".cargo");
        let config_path = cargo_dir.join("config.toml");

        if config_path.exists() {
            let config_content = fs::read_to_string(&config_path).unwrap_or_default();

            // Remove patch section if it exists
            if config_content.contains("[patch.\"https://github.com/nntin/gsnake\"]") {
                let lines: Vec<&str> = config_content.lines().collect();
                let mut new_lines = Vec::new();
                let mut in_patch_section = false;

                for line in lines {
                    if line.trim().starts_with("[patch.\"https://github.com/nntin/gsnake\"]") {
                        in_patch_section = true;
                        continue;
                    }

                    // Check if we're starting a new section
                    if in_patch_section && line.trim().starts_with('[') {
                        in_patch_section = false;
                    }

                    // Skip lines in patch section and the auto-generated comment
                    if !in_patch_section && !line.contains("Auto-generated by build.rs") {
                        new_lines.push(line);
                    }
                }

                let new_config = new_lines.join("\n");
                fs::write(&config_path, new_config.trim())
                    .expect("Failed to update .cargo/config.toml");

                println!("cargo:warning=Removed local path override (standalone mode)");
            }
        }
    }
}
