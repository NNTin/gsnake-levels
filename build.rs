use std::env;
use std::fs;
use std::path::Path;

const MODE_ENV: &str = "GSNAKE_LEVELS_BUILD_MODE";
const PATCH_SECTION_HEADER: &str = "[patch.\"https://github.com/nntin/gsnake\"]";
const PATCH_SECTION: &str = r#"
# Auto-generated by build.rs - Local override for root repository development
# This patches the git dependency to use the local sibling gsnake-core package
# Note: gsnake-core is a workspace, so we point to the actual package at engine/core
[patch."https://github.com/nntin/gsnake"]
gsnake-core = { path = "../gsnake-core/engine/core" }
"#;

#[derive(Clone, Copy, Debug)]
enum BuildMode {
    Auto,
    Local,
    Standalone,
}

impl BuildMode {
    fn from_env(raw: Option<String>) -> Self {
        let Some(raw_mode) = raw else {
            return Self::Auto;
        };

        match raw_mode.trim().to_ascii_lowercase().as_str() {
            "auto" => Self::Auto,
            "local" => Self::Local,
            "standalone" => Self::Standalone,
            other => {
                println!(
                    "cargo:warning=Unrecognized {MODE_ENV} value '{other}'. Falling back to 'auto' (accepted: auto, local, standalone)."
                );
                Self::Auto
            },
        }
    }
}

fn is_root_repo() -> bool {
    let parent_git = Path::new("../.git");
    let gsnake_core_toml = Path::new("../gsnake-core/Cargo.toml");
    parent_git.exists() && gsnake_core_toml.exists()
}

fn ensure_local_override(config_path: &Path) {
    // Read existing config if it exists
    let existing_config = if config_path.exists() {
        fs::read_to_string(config_path).unwrap_or_default()
    } else {
        String::new()
    };

    // Check if patch section already exists
    if !existing_config.contains(PATCH_SECTION_HEADER) {
        let new_config = if existing_config.is_empty() {
            PATCH_SECTION.to_string()
        } else {
            format!("{existing_config}\n{PATCH_SECTION}")
        };

        // Create .cargo directory if it doesn't exist
        if let Some(cargo_dir) = config_path.parent() {
            fs::create_dir_all(cargo_dir).expect("Failed to create .cargo directory");
        }

        fs::write(config_path, new_config).expect("Failed to write .cargo/config.toml");
        println!("cargo:warning=Created local path override in .cargo/config.toml");
    } else {
        println!("cargo:warning=Local path override already configured");
    }
}

fn remove_local_override(config_path: &Path) {
    if !config_path.exists() {
        return;
    }

    let config_content = fs::read_to_string(config_path).unwrap_or_default();

    // Remove patch section if it exists
    if config_content.contains(PATCH_SECTION_HEADER) {
        let lines: Vec<&str> = config_content.lines().collect();
        let mut new_lines = Vec::new();
        let mut in_patch_section = false;

        for line in lines {
            if line.trim().starts_with(PATCH_SECTION_HEADER) {
                in_patch_section = true;
                continue;
            }

            // Check if we're starting a new section
            if in_patch_section && line.trim().starts_with('[') {
                in_patch_section = false;
            }

            // Skip lines in patch section and the auto-generated comment
            if !in_patch_section && !line.contains("Auto-generated by build.rs") {
                new_lines.push(line);
            }
        }

        let new_config = new_lines.join("\n");
        fs::write(config_path, new_config.trim()).expect("Failed to update .cargo/config.toml");

        println!("cargo:warning=Removed local path override (standalone mode)");
    }
}

fn main() {
    println!("cargo:rerun-if-env-changed={MODE_ENV}");
    println!("cargo:rerun-if-changed=../.git");
    println!("cargo:rerun-if-changed=../gsnake-core/Cargo.toml");

    let mode = BuildMode::from_env(env::var(MODE_ENV).ok());
    let config_path = Path::new(".cargo/config.toml");

    match mode {
        BuildMode::Local => {
            println!(
                "cargo:warning=Build mode override: local (set {MODE_ENV}=local) - using local gsnake-core"
            );
            ensure_local_override(config_path);
        },
        BuildMode::Standalone => {
            println!(
                "cargo:warning=Build mode override: standalone (set {MODE_ENV}=standalone) - using git dependency for gsnake-core"
            );
            remove_local_override(config_path);
        },
        BuildMode::Auto => {
            if is_root_repo() {
                println!("cargo:warning=Root repository detected - using local gsnake-core");
                ensure_local_override(config_path);
            } else {
                println!("cargo:warning=Standalone mode - using git dependency for gsnake-core");
                remove_local_override(config_path);
            }
        },
    }
}
